# Data Model: Technical Debt Remediation and Architectural Improvements

**Feature**: Technical Debt Remediation and Architectural Improvements
**Branch**: `001-i-want-to`
**Date**: 2025-10-07

## Overview

This document defines the core data structures, validation rules, and state transitions for the refactored MCP server. All entities are extracted from the functional requirements in the feature specification.

## Core Entities

### 1. EducationDataRequest

**Purpose**: Represents a request to fetch detailed education data

**Fields**:
- `level`: string (required) - API data level (e.g., "schools", "school-districts", "college-university")
- `source`: string (required) - API data source (e.g., "ccd", "ipeds", "crdc")
- `topic`: string (required) - API data topic (e.g., "enrollment", "directory")
- `subtopic`: string[] (optional) - Additional grouping parameters (e.g., ["race", "sex"])
- `filters`: Record<string, string | number | string[] | number[]> (optional) - Query filters
- `add_labels`: boolean (optional, default: false) - Include variable labels in response
- `limit`: number (optional, default: 100) - Maximum number of results

**Validation Rules** (FR-005, FR-007, FR-008):
- `level`: non-empty string, matches known levels pattern
- `source`: non-empty string, matches known sources pattern
- `topic`: non-empty string, matches known topics pattern
- `subtopic`: if provided, array of non-empty strings
- `filters`: if provided, object with string keys and primitive or array values
- `limit`: positive integer, max value 10000 (prevent DoS via excessive data requests)
- String fields: max length 100 characters, no control characters (FR-006 sanitization)

**Relationships**:
- Maps to `EndpointMetadata` for validation of level/source/topic combination
- Transforms to `ApiRequest` for external API call
- Results cached as `CacheEntry`

---

### 2. SummaryDataRequest

**Purpose**: Represents a request to fetch aggregated education data

**Fields**:
- `level`: string (required) - API data level
- `source`: string (required) - API data source
- `topic`: string (required) - API data topic
- `subtopic`: string (optional) - Additional parameters for specific endpoints
- `stat`: string (required) - Summary statistic (e.g., "sum", "avg", "count", "median")
- `var`: string (required) - Variable name to summarize
- `by`: string | string[] (required) - Grouping variables
- `filters`: Record<string, string | number | string[] | number[]> (optional) - Query filters

**Validation Rules** (FR-005, FR-008):
- `level`, `source`, `topic`: same rules as EducationDataRequest
- `stat`: must be one of ["sum", "avg", "count", "median", "min", "max"]
- `var`: non-empty string, max length 100, alphanumeric + underscore only
- `by`: non-empty string or array of non-empty strings
- `filters`: same rules as EducationDataRequest
- String sanitization: same as EducationDataRequest (FR-006)

**Relationships**:
- Maps to `EndpointMetadata` for validation
- Transforms to `ApiRequest` with `/summaries` path appended
- Results cached as `CacheEntry`

---

### 3. EndpointMetadata

**Purpose**: Static metadata about available Education Data API endpoints (FR-004)

**Fields**:
- `level`: string - API level identifier
- `source`: string - Data source identifier
- `topic`: string - Topic identifier
- `subtopic`: string[] (optional) - Available subtopic combinations
- `mainFilters`: string[] - Primary filter parameters
- `yearsAvailable`: string - Human-readable year range (e.g., "1986–2022")

**Validation Rules**:
- All fields are defined at build time, no runtime validation needed
- Used to validate incoming requests against known endpoints

**Relationships**:
- Referenced by `EducationDataRequest` and `SummaryDataRequest` for validation
- Provided as MCP resources for discovery

**State**: Immutable, loaded from `src/config/endpoints.ts` at server startup

---

### 4. CacheEntry

**Purpose**: Represents a cached API response with TTL metadata (FR-017, FR-018)

**Fields**:
- `key`: string - Unique cache key (hash of request parameters)
- `value`: unknown - Cached response data (JSON from API)
- `timestamp`: number - Unix timestamp when cached (milliseconds)
- `ttl`: number - Time-to-live in milliseconds
- `size`: number (optional) - Approximate size in bytes for memory tracking

**Validation Rules**:
- `key`: non-empty string, generated by hashing function
- `timestamp`: positive integer
- `ttl`: positive integer, typically 300000 (5 minutes) for API responses
- Cache eviction when: current time > (timestamp + ttl)

**Relationships**:
- Created from successful `ApiRequest` responses
- Retrieved before making `ApiRequest` (cache hit avoids API call)

**State Transitions**:
1. **Created**: New entry added to cache on first request
2. **Valid**: Entry exists and timestamp + ttl > current time
3. **Expired**: timestamp + ttl <= current time, eligible for eviction
4. **Evicted**: Removed from cache (by TTL or LRU policy)

---

### 5. ApiRequest

**Purpose**: Internal representation of HTTP request to Education Data API

**Fields**:
- `url`: string - Full URL with path and query parameters
- `method`: "GET" - HTTP method (always GET for this API)
- `headers`: Record<string, string> (optional) - HTTP headers
- `timeout`: number - Request timeout in milliseconds (default: 30000)
- `retryConfig`: RetryConfig - Retry policy for this request

**Validation Rules**:
- `url`: valid URL format, HTTPS only
- `timeout`: positive integer, max 60000 (1 minute)
- Constructed internally, not from user input (no external validation needed)

**Relationships**:
- Created from `EducationDataRequest` or `SummaryDataRequest`
- Executed by API client service
- Response cached as `CacheEntry` on success

---

### 6. ValidationError

**Purpose**: Represents input validation failure (FR-005, FR-009)

**Fields**:
- `code`: "InvalidParams" - MCP error code
- `message`: string - Human-readable error description
- `field`: string (optional) - Which input field failed validation
- `expected`: string (optional) - What format was expected
- `received`: unknown (optional) - What value was actually received (sanitized)

**Validation Rules**:
- `message`: descriptive, actionable (tells user how to fix)
- `received`: sanitized to remove sensitive data before logging/returning

**Relationships**:
- Thrown by validator service
- Caught by request handlers
- Transformed to MCP error response

**Example**:
```json
{
  "code": "InvalidParams",
  "message": "Parameter 'limit' must be a positive integer not exceeding 10000",
  "field": "limit",
  "expected": "number (1-10000)",
  "received": "50000"
}
```

---

### 7. ApiError

**Purpose**: Represents error from external Education Data API (FR-011)

**Fields**:
- `statusCode`: number - HTTP status code (404, 400, 413, 500, etc.)
- `message`: string - Error message from API
- `endpoint`: string - Which API endpoint failed
- `retryable`: boolean - Whether retry should be attempted
- `originalError`: Error (optional) - Underlying error object

**Validation Rules**:
- `statusCode`: valid HTTP status code (100-599)
- `retryable`: true only for 429, 503, network timeouts

**Relationships**:
- Thrown by API client service
- Caught by request handlers
- May trigger retry logic (FR-013)
- Logged with context (FR-016, FR-029)
- Transformed to MCP error response

**State Transitions**:
1. **Thrown**: API call failed
2. **Retry Decision**: Check if retryable (429, 503, timeout)
3. **Retrying**: Exponential backoff, re-attempt request
4. **Failed**: Max retries exceeded, propagate error
5. **Logged**: Error context captured for diagnostics

---

### 8. RetryConfig

**Purpose**: Configuration for retry behavior with exponential backoff (FR-013)

**Fields**:
- `maxRetries`: number - Maximum retry attempts (default: 3)
- `baseDelay`: number - Initial delay in milliseconds (default: 1000)
- `maxDelay`: number - Maximum delay in milliseconds (default: 8000)
- `multiplier`: number - Backoff multiplier (default: 2.0)
- `jitter`: number - Random jitter factor 0-1 (default: 0.25)

**Validation Rules**:
- `maxRetries`: non-negative integer, max 5
- `baseDelay`: positive integer
- `maxDelay`: >= baseDelay
- `multiplier`: >= 1.0
- `jitter`: 0.0 to 1.0

**Calculation**:
```
delay = min(baseDelay * (multiplier ^ attempt), maxDelay)
actualDelay = delay * (1 + random(-jitter, +jitter))
```

**Example**:
- Attempt 1: ~1000ms (base delay with jitter)
- Attempt 2: ~2000ms (1000 * 2^1)
- Attempt 3: ~4000ms (1000 * 2^2)
- Attempt 4: ~8000ms (capped at maxDelay)

---

### 9. LogContext

**Purpose**: Structured logging context for observability (FR-028, FR-029, FR-030)

**Fields**:
- `requestId`: string - Unique identifier for this request
- `toolName`: string - MCP tool being called ("get_education_data" or "get_education_data_summary")
- `timestamp`: number - Unix timestamp (milliseconds)
- `params`: Record<string, unknown> - Sanitized request parameters
- `duration`: number (optional) - Request duration in milliseconds
- `error`: ErrorContext (optional) - Error details if request failed
- `cacheHit`: boolean (optional) - Whether response served from cache

**Validation Rules**:
- `requestId`: UUID v4 format
- `params`: Must be sanitized (no sensitive data, max depth 3 for nested objects)
- `duration`: non-negative number

**Relationships**:
- Created at request start
- Enriched during request processing (add duration, cache status, error)
- Passed to logger for structured output

---

### 10. HealthStatus

**Purpose**: Server health check status (FR-030)

**Fields**:
- `status`: "healthy" | "degraded" | "unhealthy"
- `timestamp`: number - Unix timestamp of health check
- `uptime`: number - Server uptime in seconds
- `checks`: Record<string, CheckStatus> - Individual component health
- `version`: string - Server version from package.json

**CheckStatus**:
- `status`: "ok" | "warning" | "error"
- `message`: string (optional) - Status description
- `lastChecked`: number - Timestamp of last check

**Validation Rules**:
- `status`: derived from `checks` (all ok = healthy, any error = unhealthy, any warning = degraded)
- Health checks: cache operational, API reachable, memory usage

**Relationships**:
- Exposed via health check endpoint (if added)
- Logged periodically for monitoring

## Validation Schema Examples (Zod)

### EducationDataRequest Schema

```typescript
import { z } from 'zod';

const EducationDataRequestSchema = z.object({
  level: z.string().min(1).max(100).regex(/^[a-z-]+$/),
  source: z.string().min(1).max(100).regex(/^[a-z]+$/),
  topic: z.string().min(1).max(100).regex(/^[a-z-]+$/),
  subtopic: z.array(z.string().min(1).max(100)).optional(),
  filters: z.record(z.union([
    z.string(),
    z.number(),
    z.array(z.string()),
    z.array(z.number())
  ])).optional(),
  add_labels: z.boolean().optional().default(false),
  limit: z.number().int().positive().max(10000).optional().default(100)
});

export type EducationDataRequest = z.infer<typeof EducationDataRequestSchema>;
```

### SummaryDataRequest Schema

```typescript
const SummaryDataRequestSchema = z.object({
  level: z.string().min(1).max(100).regex(/^[a-z-]+$/),
  source: z.string().min(1).max(100).regex(/^[a-z]+$/),
  topic: z.string().min(1).max(100).regex(/^[a-z-]+$/),
  subtopic: z.string().min(1).max(100).optional(),
  stat: z.enum(['sum', 'avg', 'count', 'median', 'min', 'max']),
  var: z.string().min(1).max(100).regex(/^[a-zA-Z0-9_]+$/),
  by: z.union([
    z.string().min(1),
    z.array(z.string().min(1))
  ]),
  filters: z.record(z.union([
    z.string(),
    z.number(),
    z.array(z.string()),
    z.array(z.number())
  ])).optional()
});

export type SummaryDataRequest = z.infer<typeof SummaryDataRequestSchema>;
```

## Summary

**Total Entities**: 10 core entities defined
- 2 input models (EducationDataRequest, SummaryDataRequest)
- 3 domain models (EndpointMetadata, CacheEntry, ApiRequest)
- 3 error models (ValidationError, ApiError, RetryConfig)
- 2 observability models (LogContext, HealthStatus)

**Validation Strategy**: Zod schemas for runtime type checking and validation
**State Management**: Immutable entities, state transitions documented for cache lifecycle
**Relationships**: Clear mappings between user input → validation → API calls → caching

Next phase: Create API contracts based on these data models.
